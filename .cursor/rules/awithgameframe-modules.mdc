---
globs: Assets/Scripts/AwithGameFrame/**/*.cs
description: AwithGameFrame模块开发规范
---

# AwithGameFrame 模块开发规范

## 框架架构设计

### 核心设计理念
- **框架定位**: 供其他开发者使用的游戏开发框架，类似GameFramework、QFramework、ET
- **核心理念**: 让开发者用的便捷，简单实用，避免过度设计
- **轻量原则**: 核心包零外部依赖，只提供抽象接口和基础工具
- **可插拔架构**: 具体实现做成可选的UPM扩展包
- **许可证安全**: 避免GPL/付费插件，只使用MIT/Apache许可证的库
- **成熟框架参考**: 参考GF、ET等成熟框架的设计思路，结合实际需求选择适合的解决方案

### 包结构设计原则

#### 设计原则
- **核心包**: 零外部依赖，只提供抽象接口和基础工具
- **扩展包**: 具体实现，可以依赖第三方库
- **可插拔**: 用户按需安装，避免强制依赖
- **轻量**: 保持核心包的轻量，避免过度设计

#### 模块划分思路
- **按功能划分**: 每个模块负责特定功能领域
- **按依赖划分**: 根据外部依赖情况决定是否独立成包
- **按使用频率划分**: 常用功能优先，特殊功能可选

## 核心层 (Core)
- **BaseManager**: 单例管理器基类，提供线程安全实现
- **EventCenter**: 事件系统，支持泛型避免装箱拆箱
- **MonoManager**: Mono生命周期管理，提供协程支持
- **PoolManager**: 对象池管理，优化性能
- **抽象接口**: 定义各模块的接口契约

## 表现层模块
### UI模块 (AwithGameFrame.UI)
- **UIManager**: 面板管理，支持分层显示
- **BasePanel**: 面板基类，自动绑定UI组件

### 音频模块 (AwithGameFrame.Audio)
- **MusicManager**: 音频播放管理，支持BGM/SFX/Voice分类

### 输入模块 (AwithGameFrame.InputSystem)
- **InputManager**: 输入事件管理，避免与Unity.Input冲突

## 工具层 (Utils)
- **GameConstants**: 游戏常量定义，避免硬编码

## 框架开发原则

### 第三方库集成原则

#### 依赖分类管理
- **核心依赖**: 框架基础功能必需的库，可以强制依赖
  - **UniTask**: 异步编程基础，性能比Task好5-10倍
  - **DOTween**: 动画系统基础，Unity社区标准
  - **Newtonsoft.Json**: JSON处理基础，官方支持
- **可选依赖**: 特定功能需要的库，必须可插拔
  - **MessagePack**: 高性能序列化，可选安装
  - **SQLite**: 数据库支持，可选安装
  - **Mirror/Photon**: 网络支持，可选安装

#### 设计原则
- **零强制依赖**: 用户可以完全移除任何可选依赖支持
- **零性能陷阱**: 只提供基础接口，不强制使用反射或ORM
- **零许可证污染**: 只使用安全的开源库，避免GPL/付费插件
- **可插拔设计**: 网络、资源管理等做成Provider模式
- **版本管理**: 使用range依赖，不锁死版本

### 模块开发原则
- 继承BaseManager<T>实现单例
- 使用EventCenter进行模块间通信
- 遵循单一职责原则
- 提供清晰的公共API
- 添加适当的错误处理
- 核心包零外部依赖

## 设计模式参考

### 成熟框架参考学习

> **注意**: 以下内容为参考学习，不是硬性要求。应根据实际需求和AwithGameFrame的核心理念（让开发者用的便捷）来选择适合的解决方案。

#### GameFramework (GF) 可参考的设计思路
- **模块化设计**: 可参考GF的模块划分思路，但要根据实际需求简化
- **事件驱动**: 可参考GF的事件系统设计，但要保持简单易用
- **资源管理**: 可参考GF的资源管理思路，但要避免过度复杂
- **对象池**: 可参考GF的对象池设计，但要保持API简洁
- **配置系统**: 可参考GF的配置管理，但要避免过度设计

#### ET框架可参考的设计思路
- **ECS架构**: 可参考ET的组件化思路，但要结合实际需求
- **热更新**: 可参考ET的热更新设计，但要根据项目需要
- **网络层**: 可参考ET的网络设计思路，但要保持简单
- **异步编程**: 可参考ET的async/await使用，但要避免过度使用
- **组件化**: 可参考ET的组件设计，但要保持易用性

#### QFramework可参考的设计思路
- **分层架构**: 可参考QFramework的分层思路，但要避免过度分层
- **命令模式**: 可参考QFramework的命令模式，但要保持简单
- **观察者模式**: 可参考QFramework的事件系统，但要避免过度设计
- **工厂模式**: 可参考QFramework的对象创建，但要保持API简洁
- **策略模式**: 可参考QFramework的算法封装，但要结合实际需求

### 框架架构模式

#### 抽象接口 + 具体实现
- **核心包**: 只定义接口，不提供具体实现
- **扩展包**: 提供具体实现，依赖第三方库
- **示例**: `INetworkChannel` 接口 + Mirror/Photon实现

#### Provider模式
- **网络层**: `INetworkProvider` + MirrorProvider/PhotonProvider
- **资源管理**: `IResourceProvider` + AddressablesProvider/ResourcesProvider
- **音频系统**: `IAudioProvider` + UnityAudioProvider/第三方AudioProvider

#### 可插拔模块设计
- **模块接口**: 定义标准接口
- **可选实现**: 通过UPM包提供不同实现
- **用户选择**: 通过manifest.json按需安装

### 第三方库集成模式

#### 可以内置的库
- **纯算法库**: MessagePack、LitJSON、protobuf-net
- **数据结构库**: UniTask、System.Collections.Generic
- **工具库**: 自研的Editor工具

#### 禁止内置的库
- **GPL许可证**: 会感染下游项目
- **付费插件**: 限制框架开源和商用
- **美术效果**: 与框架逻辑无关
- **完整框架**: Mirror、Photon等应做成Provider

### 传统设计模式

#### 何时使用配置类
- **复杂配置**: 当模块有多个相关配置项时
- **预设需求**: 需要提供不同环境预设时
- **运行时修改**: 需要支持运行时配置变更时

#### 何时提取枚举
- **多处使用**: 枚举在多个文件中被引用
- **命名冲突**: 避免与Unity内置类型冲突
- **扩展性**: 枚举可能频繁扩展时

#### 何时重构
- **代码重复**: 发现重复的配置逻辑
- **维护困难**: 配置分散难以管理
- **扩展困难**: 添加新功能需要修改多处代码

## 重构原则

### 框架开发重构原则
- **接口稳定性**: 核心接口一旦发布，必须保持向后兼容
- **扩展包独立**: 重构扩展包时不影响核心包
- **版本管理**: 重大重构应升级主版本号
- **文档同步**: 重构后及时更新API文档和示例

### 传统重构原则
- **具体问题具体分析**: 根据模块特点选择重构方案
- **渐进式重构**: 分步骤进行，保持编译通过
- **向后兼容**: 尽量保持现有API的兼容性
- **测试验证**: 重构后确保功能正常

## 框架开发红线

### 绝对禁止
- **GPL/付费插件**: 不要打包进框架，会感染下游项目
- **美术效果插件**: 框架只关心逻辑，不关心视觉效果
- **强制依赖**: 不要强制用户使用特定的第三方库
- **版本锁定**: 不要锁死第三方库版本

### 必须遵循
- **许可证安全**: 只使用MIT/Apache许可证的库
- **可插拔设计**: 具体实现做成可选的扩展包
- **零外部依赖**: 核心包不依赖任何第三方库
- **接口优先**: 先定义接口，再提供实现