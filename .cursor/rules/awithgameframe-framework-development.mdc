---
globs: Assets/Scripts/AwithGameFrame/**/*.cs
description: AwithGameFrame框架开发最佳实践
---

# AwithGameFrame 框架开发最佳实践

## 框架定位与目标

### 框架定位
- **目标用户**: 其他Unity游戏开发者
- **框架类型**: 游戏开发框架，类似GameFramework、QFramework、ET
- **核心理念**: 让开发者用的便捷，简单实用，避免过度设计
- **设计理念**: 轻量、可插拔、零外部依赖的核心包
- **学习参考**: 参考GF、ET等成熟框架的设计思路，结合实际需求选择适合的解决方案

### 核心价值
- **框架是为你服务的，不是反过来**: 框架的价值在于让开发者未来开发游戏时，能把更多的时间花在核心玩法上，而不是重复性的基础工作
- **降低开发门槛**: 提供开箱即用的游戏开发工具
- **提高开发效率**: 标准化常用功能，减少重复造轮子
- **保持灵活性**: 可插拔架构，用户按需选择功能
- **避免许可证风险**: 只使用安全的开源库
- **简单易用**: 优先考虑开发者的使用体验，避免过度复杂

### 设计哲学
- **实用主义优先**: 在理想与现实中找到平衡，选择"选择性地强制依赖"来平衡轻量与实用性
- **持续验证**: 通过用户反馈和数据驱动来校准设计决策，避免主观臆断
- **适度设计**: 避免过度抽象，在简单性和扩展性之间找到平衡点
- **技术债管理**: 为每个设计决策准备应对未来变化的预案

## 成熟框架参考学习

> **重要提醒**: 以下内容为参考学习，不是硬性要求。应根据实际需求和AwithGameFrame的核心理念（让开发者用的便捷）来选择适合的解决方案。避免照搬其他框架，要结合实际需求进行简化。

### GameFramework (GF) 可参考的设计思路
- **模块化设计**: 可参考GF的模块划分思路，但要根据实际需求简化
- **事件系统**: 可参考GF的事件驱动架构，但要保持简单易用
- **资源管理**: 可参考GF的资源管理思路，但要避免过度复杂
- **对象池**: 可参考GF的对象池设计，但要保持API简洁
- **配置系统**: 可参考GF的配置管理，但要避免过度设计

### ET框架可参考的设计思路
- **ECS架构**: 可参考ET的组件化思路，但要结合实际需求
- **热更新**: 可参考ET的热更新设计，但要根据项目需要
- **网络层**: 可参考ET的网络设计思路，但要保持简单
- **组件化**: 可参考ET的组件设计，但要保持易用性
- **异步编程**: 可参考ET的async/await使用，但要避免过度使用

### QFramework可参考的设计思路
- **分层架构**: 可参考QFramework的分层思路，但要避免过度分层
- **命令模式**: 可参考QFramework的命令模式，但要保持简单
- **观察者模式**: 可参考QFramework的事件系统，但要避免过度设计
- **工厂模式**: 可参考QFramework的对象创建，但要保持API简洁
- **策略模式**: 可参考QFramework的算法封装，但要结合实际需求

## 包架构设计原则

### 三包架构设计
- **Core Package**: 零外部依赖，纯接口定义和基础工具类
- **Foundation Package**: 包含Core + 核心依赖，提供基础实现
- **Extensions Package**: 包含Foundation + 扩展功能，提供完整功能

### 设计理念
- **核心包**: 零外部依赖，只使用Unity内置API
- **基础包**: 包含核心依赖，提供开箱即用的基础功能
- **扩展包**: 包含基础包 + 扩展功能，提供完整功能
- **用户项目**: 通过manifest.json按需安装包
- **轻量原则**: 保持核心包的轻量，避免过度设计

### 模块划分原则
- **按功能划分**: 每个模块负责特定功能领域
- **按依赖划分**: 根据外部依赖情况决定是否独立成包
- **按使用频率划分**: 常用功能优先，特殊功能可选
- **按复杂度划分**: 简单功能可合并，复杂功能独立

### 第三方库集成模块设计原则

#### 依赖管理策略

##### 核心依赖的"软绑定"原则
- **UniTask**: 提供 `IAsyncProvider` 接口，默认实现使用UniTask
  - 原因：Unity异步编程标准，性能比Task好5-10倍
  - 替代方案：支持System.Threading.Tasks实现
- **DOTween**: 提供 `IAnimationProvider` 接口，默认实现使用DOTween
  - 原因：Unity社区最流行的动画库，API设计优秀
  - 替代方案：支持Unity内置Animation实现
- **Newtonsoft.Json**: 提供 `ISerializationProvider` 接口，默认实现使用Newtonsoft.Json
  - 原因：.NET生态系统JSON标准，功能完整
  - 替代方案：支持Unity内置JsonUtility实现

##### 可选依赖管理
- **MessagePack**: 高性能序列化，可选安装
- **SQLite**: 数据库支持，可选安装
- **Mirror/Photon**: 网络支持，可选安装

##### 技术债管理
- **版本兼容性**: 明确支持的最低和最高版本范围
- **冲突检测**: 提供版本冲突检测工具
- **迁移预案**: 为每个核心依赖准备替代方案
- **社区监控**: 定期评估依赖库的维护状态

#### 设计原则
- **软绑定优先**: 通过抽象接口降低技术绑定风险
- **零性能陷阱**: 只提供基础接口，不强制使用反射或ORM
- **零许可证污染**: 只使用安全的开源库，避免GPL/付费插件
- **接口优先**: 核心包定义接口，具体实现可替换
- **用户选择**: 让用户自己选择具体的实现方案

### 包结构设计思路
- **Core Package**: 零外部依赖，纯接口定义和基础工具类
- **Foundation Package**: 包含Core + 核心依赖，提供开箱即用的基础实现
- **Extensions Package**: 包含Foundation + 扩展功能，提供完整功能
- **未来扩展**: 可考虑拆分为更多独立的功能包

## 第三方库集成策略

### 核心依赖库（可以强制依赖）
| 库名 | 许可证 | 用途 | 集成方式 | 说明 |
|------|--------|------|----------|------|
| **UniTask** | MIT | 异步编程 | 源码内嵌 | 性能比Task好5-10倍，框架基础 |
| **DOTween** | MIT | 动画系统 | Unity Package | Unity社区标准，性能优秀 |
| **Newtonsoft.Json** | MIT | JSON处理 | UPM依赖 | 官方支持，功能完整 |

### 可选依赖库（必须可插拔）
| 库名 | 许可证 | 用途 | 集成方式 | 说明 |
|------|--------|------|----------|------|
| **MessagePack** | MIT | 高性能序列化 | UPM依赖 | 可选安装，性能提升 |
| **SQLite** | MIT | 数据库支持 | UPM依赖 | 可选安装，复杂查询 |
| **Mirror** | MIT | 网络框架 | Unity Package | 可选安装，多人游戏 |
| **LitJSON** | MIT | 轻量JSON | 源码内嵌 | 可选安装，轻量级 |

### 禁止内置的库
| 类型 | 示例 | 原因 | 替代方案 |
|------|------|------|----------|
| **GPL许可证** | 某些开源库 | 会感染下游项目 | 寻找MIT替代品 |
| **付费插件** | DOTween, Odin Inspector | 限制框架开源 | 做成可选扩展包 |
| **美术效果** | Toony Colors, Stylized Water | 与框架逻辑无关 | 由用户自行选择 |
| **完整框架** | Mirror, Photon | 应做成Provider | 抽象接口+具体实现 |

## 模块开发指导

### 需求验证机制

#### 持续的用户反馈收集
- **用户调研**: 每季度进行用户调研，了解不同游戏类型的需求差异
- **数据分析**: 统计API使用率和功能需求，基于数据调整功能优先级
- **社区反馈**: 分析GitHub Issues和讨论，收集用户痛点
- **项目分析**: 分析用户项目类型分布，校准"通用需求"定义

#### 数据驱动的设计决策
- **功能使用率统计**: 建立功能使用率统计系统
- **用户项目类型分析**: 分析不同游戏类型的需求差异
- **社区讨论跟踪**: 跟踪社区讨论和Issue，识别共同需求
- **动态调整机制**: 根据反馈动态调整"通用需求"定义

### 模块开发流程
1. **需求分析**: 明确模块的实际需求和目标用户
2. **需求验证**: 通过用户调研和数据分析验证需求
3. **参考学习**: 研究GF、ET等成熟框架的对应模块实现，但不要照搬
4. **简化设计**: 根据AwithGameFrame的核心理念（让开发者用的便捷）进行简化
5. **依赖分析**: 识别核心依赖和可选依赖，决定包结构
6. **接口设计**: 根据接口设计决策树，明智选择何时使用接口
7. **Provider模式**: 为不同实现提供统一的接口，但要避免过度设计
8. **性能考虑**: 使用UniTask等核心依赖，避免反射、ORM等性能陷阱
9. **测试验证**: 确保接口的易用性和扩展性
10. **文档编写**: 提供详细的使用文档和示例
11. **持续改进**: 根据用户反馈持续优化和调整

### 成熟框架模块参考

> **注意**: 以下内容为参考学习，不是硬性要求。应根据实际需求和AwithGameFrame的核心理念（让开发者用的便捷）来选择适合的解决方案。

#### 数据持久化模块 (可参考GF)
- **学习要点**: 可参考GF的数据表系统、配置管理思路
- **设计思路**: 支持多种存储方式，统一的数据访问接口，但要保持简单
- **实现方式**: 抽象接口 + 具体存储Provider，但要避免过度复杂
- **简化原则**: 优先考虑常用功能，避免过度设计

#### UI系统模块 (可参考QFramework)
- **学习要点**: 可参考QFramework的UI分层、事件绑定思路
- **设计思路**: 支持多层级UI管理，自动组件绑定，但要保持易用
- **实现方式**: 面板基类 + 管理器 + 事件系统，但要避免过度复杂
- **简化原则**: 优先考虑常用场景，保持API简洁

#### 网络模块 (可参考ET)
- **学习要点**: 可参考ET的Actor模型、消息路由思路
- **设计思路**: 支持多种网络库，统一的网络接口，但要保持简单
- **实现方式**: 抽象接口 + Mirror/Photon Provider，但要避免过度设计
- **简化原则**: 优先考虑常用功能，避免过度抽象

#### 资源管理模块 (可参考GF)
- **学习要点**: 可参考GF的资源加载、对象池管理思路
- **设计思路**: 支持多种资源加载方式，高效的对象复用，但要保持易用
- **实现方式**: 抽象接口 + Addressables/Resources Provider，但要避免过度复杂
- **简化原则**: 优先考虑常用场景，保持API简洁

## 接口设计原则

### 接口设计决策树

#### 何时使用接口
- ✅ **多种实现方式**: 功能有多种实现方式（如存储、序列化、网络）
- ✅ **频繁替换**: 需要频繁替换或扩展的组件
- ✅ **跨模块交互**: 跨模块交互的边界
- ✅ **第三方抽象**: 第三方库的抽象层
- ✅ **核心依赖抽象**: 为核心依赖提供抽象层

#### 何时直接实现
- ✅ **简单工具类**: 数学计算、字符串处理等工具类
- ✅ **稳定核心功能**: 事件系统、基础管理器等
- ✅ **单一实现**: 只有一种实现方式的功能
- ✅ **内部辅助类**: 内部使用的辅助类
- ✅ **性能敏感**: 性能敏感且稳定的功能

#### 设计原则
- **YAGNI原则**: 不要为了设计而设计
- **KISS原则**: 保持简单，避免过度复杂
- **实用优先**: 优先考虑开发者的使用体验
- **适度抽象**: 在简单性和扩展性之间找到平衡

### 抽象接口设计示例
```csharp
// 核心依赖抽象接口
public interface IAsyncProvider
{
    UniTask<T> FromResult<T>(T result);
    UniTask Delay(int milliseconds);
    UniTask WhenAll(params UniTask[] tasks);
}

// 功能抽象接口（多种实现）
public interface IStorageProvider
{
    UniTask<DataOperationResult> SaveAsync<T>(string key, T data);
    UniTask<(T data, DataOperationResult result)> LoadAsync<T>(string key);
}

// 简单工具类（直接实现）
public static class MathHelper
{
    public static float Clamp(float value, float min, float max) => Mathf.Clamp(value, min, max);
    public static Vector3 Lerp(Vector3 a, Vector3 b, float t) => Vector3.Lerp(a, b, t);
}
```

### Provider模式实现
```csharp
// UniTask实现
public class UniTaskProvider : IAsyncProvider
{
    public UniTask<T> FromResult<T>(T result) => UniTask.FromResult(result);
    public UniTask Delay(int milliseconds) => UniTask.Delay(milliseconds);
    public UniTask WhenAll(params UniTask[] tasks) => UniTask.WhenAll(tasks);
}

// 存储Provider实现
public class JsonFileStorageProvider : IStorageProvider
{
    // JSON文件存储的具体实现
}
```

## 版本管理策略

### 语义化版本控制
- **主版本号**: 不兼容的API修改
- **次版本号**: 向下兼容的功能性新增
- **修订号**: 向下兼容的问题修正

### 依赖版本管理
```json
// package.json中的依赖声明
{
  "dependencies": {
    "com.unity.nuget.newtonsoft-json": "^3.2.0",
    "com.unity.nuget.messagepack": "^1.0.0"
  }
}
```

### 技术债管理策略
- **版本兼容性**: 明确支持的最低和最高版本范围
- **冲突检测**: 提供版本冲突检测和解决工具
- **迁移预案**: 为每个核心依赖准备替代方案
- **社区监控**: 定期评估依赖库的维护状态和社区活跃度
- **升级路径**: 提供详细的依赖升级和迁移指南

### 向后兼容原则
- **接口稳定性**: 核心接口一旦发布，必须保持兼容
- **废弃策略**: 使用Obsolete标记废弃API，给用户迁移时间
- **迁移指南**: 提供详细的API迁移文档
- **渐进式升级**: 支持渐进式升级，避免破坏性变更

## 文档与示例

### 必须提供的文档
- **README.md**: 框架概述和快速开始
- **API文档**: 详细的接口说明
- **示例项目**: 完整的使用示例
- **迁移指南**: 版本升级指南

### 示例代码要求
- **完整性**: 提供可运行的完整示例
- **最佳实践**: 展示推荐的使用方式
- **错误处理**: 包含错误处理示例
- **性能优化**: 展示性能优化技巧

## 测试策略

### 测试覆盖范围
- **单元测试**: 核心功能测试
- **集成测试**: 模块间协作测试
- **性能测试**: 关键路径性能测试
- **兼容性测试**: 不同Unity版本测试

### 测试环境
- **Unity版本**: 支持LTS版本
- **平台测试**: Windows, Mac, Linux
- **构建测试**: 确保能正常构建

## 发布流程

### 发布前检查
- [ ] 所有测试通过
- [ ] 文档更新完成
- [ ] 示例项目验证
- [ ] 许可证检查通过
- [ ] 版本号更新

### 发布渠道
- **GitHub**: 源码和文档
- **Unity Asset Store**: 可视化安装
- **UPM**: 包管理器安装
- **Git**: 直接依赖安装

## 社区维护

### 开源协作
- **Issue跟踪**: 及时响应用户问题
- **PR审核**: 严格审核贡献代码
- **文档维护**: 保持文档与代码同步
- **版本发布**: 定期发布稳定版本

### 用户支持
- **快速响应**: 24小时内响应Issue
- **详细解答**: 提供完整的解决方案
- **示例更新**: 根据用户反馈更新示例
- **最佳实践**: 分享使用最佳实践

### 持续改进机制
- **用户反馈收集**: 建立多渠道用户反馈收集系统
- **数据分析**: 基于使用数据调整功能优先级
- **社区参与**: 鼓励社区贡献和讨论
- **定期评估**: 定期评估框架发展方向和策略调整